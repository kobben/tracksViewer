<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>D3: Loading GeoJSON data and generating visuali</title>
		<script type="text/javascript" src="D3/d3.v3.min.js"></script>
		<script src="D3/d3.geo.projection.v0.min.js"></script>
		<script src="D3/topojson.v1.min.js"></script>
		<!-- <script type="text/javascript" src="http://maps.google.com/maps/api/js?sensor=true"></script> -->
		<link rel="stylesheet" type="text/css" href="svg.css">


	</head>
	<body>

	<script type="text/javascript">


//variables
var distScale, parseDate, timeScale
//Width and height
			var w = 600;
			var h = 538;
					var test;

//Define map projection
			var projection = d3.geo.mercator()
									.rotate([0,0]) //lon,lat]
									.center([6.895,52.2185]) //[lon,lat]
									.translate([w/2, h/2])
									.precision(0.1)
									.scale([2500000]);

//Define path generator
			var path = d3.geo.path()
							 .projection(projection);


//Create SVG element
			var svg = d3.select("body")
						.append("svg:svg")
						.attr("id", "mapSVG")
						.attr("width", w)
						.attr("height", h)
    					.append("svg:g");


//Load in points data and visualise
				d3.json("data/trackNw.geojson", function(trackpoint) {
					svg.selectAll("circle")
						.data(trackpoint.features)
						//.data(trackpoint.filter(function(d) {return d.features.properties.stop != 0;}))
						.enter()
						.append("circle")
						.attr("cx", function (d) {return projection(d.geometry.coordinates)[0]})
						.attr("cy", function (d) {return projection(d.geometry.coordinates)[1]})
						.attr("r",function (d) {if (d.properties.stop != 0) {return "4"}else{ return "1"}})
						.attr("class", function (d) {if (d.properties.stop != 0) {return "stop"}else{ return "track"}})
					});	//end of function loading and visualising point data

//the time-distance relations

var SVGwidth = 650, SVGheight = 170;
var xMargin = 10, yT = 150, yD = 70;
var totaldistance = 70, totaltime = 70, distancescale=10, timescale = 10, linelength=600;
var track, tracks, lines;



//variables for the  various time-distance visualisations
var dateFormat = d3.time.format("%d-%m-%YT%H:%M:%S");
function parseMyDate(DateStr) {
    //parses string to Date and expresses as ms since epoch (+ expression)
    return +dateFormat.parse(DateStr);
}

//these min-max values should be really be retrieved from data:
var earliestTime = parseMyDate("9-1-2014T10:37:32");
var latestTime = parseMyDate("9-1-2014T11:11:24");
var smallestDist = 0;
var largestDist = 2.1179;

//vars domain for the scales
var timeScale = d3.scale.linear()
        .domain([earliestTime, latestTime])
        .range([0, linelength]);
var distScale = d3.scale.linear()
        .domain([smallestDist, largestDist])
        .range([0, linelength]);



//create SVG placeholders

var svgScale = d3.select("body").append("svg")
        .attr("id", "scales1SVG")
        .attr("width", SVGwidth)
        .attr("height", SVGheight)
        ;

var svgScale2 = d3.select("body").append("svg")
        .attr("id", "scales2SVG")
        .attr("width", SVGwidth)
        .attr("height", SVGheight)
        ;

var svgScale3 = d3.select("body").append("svg")
        .attr("id", "scales3SVG")
        .attr("width", SVGwidth)
        .attr("height", SVGheight)
        ;



//Overall title
svgScale.append("text")
        .attr("x", xMargin+10)
        .attr("y", yD-35)
		.attr("fill", "red")
		.attr("font-size", 20)
        .text("COMMON REPRESENTATION (both scales fixed)")
;

svgScale2.append("text")
        .attr("x", xMargin+10)
        .attr("y", yD-35)
		.attr("fill", "red")
		.attr("font-size", 20)
        .text("FROM TIME TO GEOGRAPHY: ")
;
svgScale3.append("text")
        .attr("x", xMargin+10)
        .attr("y", yD-35)
		.attr("fill", "red")
		.attr("font-size", 20)
        .text("FROM GEOGRAPHY TO TIME")
;


//DISTANCE
//draw baseline + text for distance
svgScale.append("line")
        .attr("id","distanceLine")
        .attr("y1", yD)
        .attr("y2", yD)
        .attr("x1", xMargin)
        .attr("x2", xMargin + linelength)
        ;
var distAxis = d3.svg.axis()
        .scale(distScale)
        .orient("bottom");
svgScale.append("g")
        .attr("class", "axis")
        .attr("transform", "translate(10,70)" )
        .call(distAxis)
        ;
svgScale.append("text")
        .attr("x", xMargin+10)
        .attr("y", yD-5)
		.attr("fill", "grey")
		.attr("font-size", 10)
        .text("DISTANCE")
;

svgScale2.append("line")
        .attr("id","distanceLine")
        .attr("y1", yD)
        .attr("y2", yD)
        .attr("x1", xMargin)
        .attr("x2", xMargin + linelength)
        ;
svgScale2.append("text")
        .attr("x", xMargin+10)
        .attr("y", yD-5)
		.attr("fill", "grey")
		.attr("font-size", 10)
        .text("DISTANCE")
;
svgScale3.append("line")
        .attr("id","distanceLine")
        .attr("y1", yD)
        .attr("y2", yD)
        .attr("x1", xMargin)
        .attr("x2", xMargin + linelength)
        ;
svgScale3.append("text")
        .attr("x", xMargin+10)
        .attr("y", yD-5)
		.attr("fill", "grey")
		.attr("font-size", 10)
        .text("DISTANCE")
;


//TIME
//draw baseline + text for time
svgScale.append("line")
        .attr("id","timeLine")
        .attr("y1", yT)
        .attr("y2", yT)
        .attr("x1", xMargin)
        .attr("x2", xMargin + linelength)
        ;
svgScale.append("text")
        .attr("x", xMargin+10)
        .attr("y", yT-5)
		.attr("fill", "grey")
		.attr("font-size", 10)
        .text("TIME")
;

svgScale2.append("line")
        .attr("id","timeLine")
        .attr("y1", yT)
        .attr("y2", yT)
        .attr("x1", xMargin)
        .attr("x2", xMargin + linelength)
        ;
svgScale2.append("text")
        .attr("x", xMargin+10)
        .attr("y", yT-5)
		.attr("fill", "grey")
		.attr("font-size", 10)
        .text("TIME")
;
svgScale3.append("line")
        .attr("id","timeLine")
        .attr("y1", yT)
        .attr("y2", yT)
        .attr("x1", xMargin)
        .attr("x2", xMargin + linelength)
        ;
svgScale3.append("text")
        .attr("x", xMargin+10)
        .attr("y", yT-5)
		.attr("fill", "grey")
		.attr("font-size", 10)
        .text("TIME")
;

//load trackdata
d3.json("data/trackNw.geojson", function(error, tracks) { //when read, do function
//console.log(tracks);

//COMMON
//create distance events
	svgScale.selectAll(".distancecircle")
			.data(tracks.features.filter(function(d) { return d.properties.stop != 0; } ))
			.enter()
			.append("circle")
            .attr("class", "distancecircle")
            .attr("cx", function(d) {return 10+(distScale(d.properties.distance))})
            .attr("cy", yD)
            .attr("r", "2")




//create time events
    svgScale.selectAll(".timecircle")
            .data(tracks.features.filter(function(d) { return d.properties.stop != 0; } ))
            .enter()
            .append("circle")
            .attr("class", "timecircle")
            .attr("cx", function(d) {return 10+(timeScale(parseMyDate(d.properties.date + "T" + d.properties.time)))})
            .attr("cy", yT)
            .attr("r", "2")

//create connectors
    svgScale.selectAll(".connectors")
            .data(tracks.features.filter(function(d) { return d.properties.stop != 0; } ))
            .enter()
			.append("line")
            .attr("class", "connectors")
            .attr("x1", function(d) {return 10+(timeScale(parseMyDate(d.properties.date + "T" + d.properties.time)))})
            .attr("y1", yT)
            .attr("x2", function(d) {return 10+(distScale(d.properties.distance))})
            .attr("y2", yD)
/*
//TIME TO GEO
//create distance events
    svgScale2.selectAll(".distancecircle")
        .data(tracks)
            .enter().append("circle")
            .attr("class", "distancecircle")
            .attr("cx", function(d) {
                    return xMargin + dist1Xscale(d.properties.dist); })
            .attr("cy", yD)
            .attr("r", "5")

//create time events
    svgScale2.selectAll(".timecircle")
            .data(tracks)
            .enter().append("circle")
            .attr("class", "timecircle")
            .attr("cx", function(d) {
                return xMargin + (d.properties.timestamp * timescale); })
            .attr("cy", yT)
            .attr("r", "5")

//create connectors
    svgScale2.selectAll(".connectors")
            .data(tracks)
            .enter().append("line")
            .attr("class", "connectors")
            .attr("x1", function(d) {
                return xMargin + (d.properties.timestamp * timescale); })
            .attr("y1", yT)
            .attr("x2", function(d) {
                return xMargin + (d.properties.dist * distancescale); })
            .attr("y2", yD)

//GEO TO TIME
//create distance events
    svgScale3.selectAll(".distancecircle")
        .data(tracks)
            .enter().append("circle")
            .attr("class", "distancecircle")
            .attr("cx", function(d) {
                    return xMargin + dist1Xscale(d.properties.dist); })
            .attr("cy", yD)
            .attr("r", "5")

//create time events
    svgScale3.selectAll(".timecircle")
            .data(tracks)
            .enter().append("circle")
            .attr("class", "timecircle")
            .attr("cx", function(d) {
                return xMargin + (d.properties.timestamp * timescale); })
            .attr("cy", yT)
            .attr("r", "5")

//create connectors
    svgScale3.selectAll(".connectors")
            .data(tracks)
            .enter().append("line")
            .attr("class", "connectors")
            .attr("x1", function(d) {
                return xMargin + (d.properties.timestamp * timescale); })
            .attr("y1", yT)
            .attr("x2", function(d) {
                return xMargin + (d.properties.dist * distancescale); })
            .attr("y2", yD)
*/
	})

		</script>
	</body>
</html>